--- a/drivers/net/phy/mdio-ipq4019.c
+++ b/drivers/net/phy/mdio-ipq4019.c
@@ -10,6 +10,7 @@
 #include <linux/of_address.h>
 #include <linux/of_mdio.h>
 #include <linux/of_gpio.h>
+#include <linux/of.h>
 #include <linux/phy.h>
 #include <linux/platform_device.h>
 
@@ -27,6 +28,8 @@
 
 struct ipq4019_mdio_data {
 	void __iomem	*membase;
+	u32 mdio_offset;
+	u32 mdio_offset_limit;
 };
 
 static int ipq4019_mdio_wait_busy(struct mii_bus *bus)
@@ -44,6 +47,9 @@
 	struct ipq4019_mdio_data *priv = bus->priv;
 	unsigned int cmd;
 
+	if(mii_id < priv->mdio_offset_limit)
+			mii_id += priv->mdio_offset;
+
 	/* Reject clause 45 */
 	if (regnum & MII_ADDR_C45)
 		return -EOPNOTSUPP;
@@ -73,6 +79,9 @@
 	struct ipq4019_mdio_data *priv = bus->priv;
 	unsigned int cmd;
 
+	if(mii_id < priv->mdio_offset_limit)
+			mii_id += priv->mdio_offset;
+
 	/* Reject clause 45 */
 	if (regnum & MII_ADDR_C45)
 		return -EOPNOTSUPP;
@@ -145,6 +154,7 @@
 {
 	struct ipq4019_mdio_data *priv;
 	struct mii_bus *bus;
+	struct device_node *mdio_node;
 	int ret;
 
 	ret = ipq4019_phy_reset(pdev);
@@ -159,6 +169,10 @@
 
 	priv = bus->priv;
 
+	mdio_node = of_node_get(pdev->dev.of_node);
+	of_property_read_u32(mdio_node, "qcom,mdio_offset", &priv->mdio_offset);
+	of_property_read_u32(mdio_node, "qcom,mdio_offset_limit", &priv->mdio_offset_limit);
+
 	priv->membase = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(priv->membase))
 		return PTR_ERR(priv->membase);
